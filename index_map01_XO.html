
<!DOCTYPE html>
<html>

<head>
    <title>MAP01_0910M_P3_OO</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/jscastro76/threebox@v.2.2.2/dist/threebox.min.js"
        type="text/javascript"></script>
    <link href="https://cdn.jsdelivr.net/gh/jscastro76/threebox@v.2.2.2/dist/threebox.css" rel="stylesheet">
    <script src="js/three-js-capsule-geometry.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <style>
        body,
        html {
            width: 100%;
            height: 100%;
            margin: 0;
        }

        #map {
            width: 100%;
            height: 100%;
        }


        .mapboxgl-ctrl-reset {
        font-size: 18px; line-height: 28px;    /* æ–‡å­—ç½®ä¸­ */
        }
        .mapboxgl-ctrl-reset::before {
        content: "â†º";               /* ä¹Ÿå¯æ›æˆ âŒ‚ æˆ– ğŸ  ç­‰ */
        }


    </style>
</head>

<body>

    <div id='map' class='map'></div>

    <script>
        const blockLabels = [
        { block: 50,  text: 'A',   height: 75 },
        { block: 4, text: 'B',   height: 75 },
        { block: 103, text: 'C', height: 75 },
        { block: 60, text: 'D', height: 75 }
        ];


        var capsuleHeight = 60;
        var centerCoord = [121.5305, 25.04, 60];

        mapboxgl.accessToken = 'pk.eyJ1IjoicGlhb3BpYW9lbiIsImEiOiJjbTlsa2Y2d28wM2d4MmxyNzhqem12MWd1In0.NbcsNNsBZtV-pLab8nBtPg';

        const initialView = {                      //  â† ä¾ä½ çš„è¨­å®šæ”¹å€¼
            center: [121.5305, 25.04],               // åªæœ‰ç¶“ç·¯åº¦å³å¯
            zoom:   16.4,
            pitch:  60,
            bearing: 0
            };

        var map = new mapboxgl.Map({
            container: 'map',
            
            // style: 'mapbox://styles/mapbox/streets-v11',
            style:'mapbox://styles/piaopiaoen/cm9lof90y009n01soaal5dqzr',
            center: centerCoord,
            zoom: 17,
            pitch: 60,
            antialias: true,

            localIdeographFontFamily: 'Noto Sans CJK TC', // æ”¯æ´ä¸­æ–‡çš„å­—é«”
           language: 'zh-Hant' // è¨­ç½®ç‚ºç¹é«”ä¸­æ–‡
        });


        /* â˜…â˜…â˜… åŠ å…¥æŒ‡åŒ—é‡ â˜…â˜…â˜… */
        const compassControl = new mapboxgl.NavigationControl({
            showZoom: false,        // ä¸é¡¯ç¤º + / âˆ’ æŒ‰éˆ•ï¼›å¦‚éœ€å°±æ”¹ç‚º true
            visualizePitch: true    // ä¿ç•™ pitch æŒ‡ç¤º
        });
        map.addControl(compassControl, 'top-left'); // å¯æ”¹ 'top-right' ç­‰ä½ç½®
        /* â˜…â˜…â˜… æŒ‡åŒ—é‡çµæŸ â˜…â˜…â˜… */


     class ResetViewControl {
        onAdd(map) {
            this._map = map;

            // å¤–å±¤å®¹å™¨ï¼ˆä¿ç•™ Mapbox æ¨£å¼ï¼‰
            const wrapper = document.createElement('div');
            wrapper.className = 'mapboxgl-ctrl mapboxgl-ctrl-group';

            // æŒ‰éˆ•
            const btn = document.createElement('button');
            btn.className = 'mapboxgl-ctrl-icon mapboxgl-ctrl-reset';
            btn.type  = 'button';
            btn.title = 'å›åˆ°åˆå§‹è¦–è§’';

            // é»æ“Šäº‹ä»¶ï¼šé£›å›åˆå§‹åƒæ•¸
            btn.onclick = () => {
            map.flyTo({
                center:  initialView.center,
                zoom:    initialView.zoom,
                pitch:   initialView.pitch,
                bearing: initialView.bearing,
                duration: 1000            // å‹•ç•« 1 ç§’
            });
            };

            wrapper.appendChild(btn);
            this._btn = btn;
            return wrapper;
        }
        
        onRemove() {
            this._btn.parentNode.remove();
            this._map = undefined;
        }
    }
        map.addControl(new ResetViewControl(), 'top-left');
       
        const baseColors = [
        "#b2182b", //  3 ç†±
        "#ef8a62", //  2
        "#fddbc7", //  1
        "#ffffff", //  0
        "#d1e5f0", // -1
        "#67a9cf", // -2
        "#2166ac"  // -3 å†·
        ];

        // 2. è½‰æˆç·šæ€§ç©ºé–“ HEXï¼ˆThree.js å…§éƒ¨ç”¨ï¼‰
        //    é€™ä¸€æ­¥åªæœƒåœ¨è¼‰å…¥è…³æœ¬æ™‚åŸ·è¡Œä¸€æ¬¡
        const colors = baseColors.map(hex => {
        // THREE.Color æœƒæŠŠå­—ä¸²ç•¶ä½œ sRGB è®€é€²ä¾†
        // convertSRGBToLinear() å¾Œï¼Œå†ç”¨ getHexString() è¼¸å‡ºç·šæ€§ç©ºé–“çš„ 24â€‘bit HEX
        const linear = new THREE.Color(hex).convertSRGBToLinear();
        return `#${linear.getHexString()}`;
        });

        function getPMVColor(pmv) {
            if (pmv < -2.5) {
                return colors[6];
            }
            if (pmv < -1.5 && pmv >= -2.5) {
                return colors[5];
            }
            if (pmv < -0.5 && pmv >= -1.5) {
                return colors[4];
            }
            if (pmv < 0.5 && pmv >= -0.5) {
                return colors[3];
            }
            if (pmv < 1.5 && pmv >= 0.5) {
                return colors[2];
            }
            if (pmv < 2.5 && pmv >= 1.5) {
                return colors[1];
            }
            if (pmv >= 2.5) {
                return colors[0];
            }
        }

        function getSubjectTempColor(sTemp) {
            if (sTemp < -2.5) {
                return colors[6];
            }
            if (sTemp< -1.5 && sTemp >= -2.5) {
                return colors[5];
            }
            if (sTemp < -0.5 && sTemp >= -1.5) {
                return colors[4];
            }
            if (sTemp < 0.5 && sTemp >= -0.5) {
                return colors[3];
            }
            if (sTemp < 1.5 && sTemp >= 0.5) {
                return colors[2];
            }
            if (sTemp < 2.5 && sTemp >= 1.5) {
                return colors[1];
            }
            if (sTemp >= 2.5) {
                return colors[0];
            }
        }

        /** å»ºç«‹ä¸€å€‹ 3D æ–‡å­—ï¼Œç›´æ¥æ”¾åˆ° Threebox */
        function makeTopLabel(font, lon, lat, text, height) {
            const geo = new THREE.TextGeometry(text, {
                font: font,
                size: 10,        // æ–‡å­—å¤§å°ï¼ˆè‡ªè¡Œå¾®èª¿ï¼‰
                height: 0.3     // åšåº¦
            });

            // ä¿®æ”¹æ–‡å­—é¡è‰²
            const mat = new THREE.MeshBasicMaterial({ color: '#FFD700' }); // é‡‘é»ƒè‰²
            const mesh = new THREE.Mesh(geo, mat);

            // è¨ˆç®—æ–‡å­—çš„å¯¬åº¦
            geo.computeBoundingBox();
            const textWidth = geo.boundingBox.max.x - geo.boundingBox.min.x;

            // å¢åŠ å…‰æšˆæ•ˆæœ
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: '#FFD700', // å…‰æšˆé¡è‰²
                transparent: true,
                opacity: 0.5
            });
            const glowGeo = new THREE.TextGeometry(text, {
                font: font,
                size: 10.5,        // å…‰æšˆç¨å¾®å¤§ä¸€é»
                height: 0.1       // å…‰æšˆåšåº¦è¼ƒè–„
            });
            const glowMesh = new THREE.Mesh(glowGeo, glowMaterial);

            // è¨ˆç®—å…‰æšˆçš„å¯¬åº¦
            glowGeo.computeBoundingBox();
            const glowWidth = glowGeo.boundingBox.max.x - glowGeo.boundingBox.min.x;

            /* â˜… è®“æ–‡å­—ç«™èµ·ä¾†ï¼Œä¸”æ­£é¢å‘é¡é ­ â˜… */
            geo.center(); // ç¢ºä¿æ–‡å­—çš„å¹¾ä½•ä¸­å¿ƒå°é½Š
            glowGeo.center(); // ç¢ºä¿å…‰æšˆçš„å¹¾ä½•ä¸­å¿ƒå°é½Š
            geo.rotateX(Math.PI / 2);
            geo.rotateZ(Math.PI);
            glowGeo.rotateX(Math.PI / 2);
            glowGeo.rotateZ(Math.PI);

            // èª¿æ•´ä½ç½®ä»¥è£œå„Ÿå¯¬åº¦åç§»
            const offset = textWidth / 2;
            const adjustedLon = calculateNewCoordinates(lat, lon, -offset, 90).lon;

            const obj3d = tb.Object3D({ obj: new THREE.Group().add(glowMesh, mesh), units: 'meters' });
            obj3d.setCoords([adjustedLon, lat, height]);
            tb.add(obj3d);
        }

        /** æŠŠ blockLabels è¿´åœˆè·‘ä¸€éï¼Œé€ä¸€åŠ æ–‡å­— */
        function addAllLabels(font, data) {
        blockLabels.forEach(item => {
            // æª¢æŸ¥ JSON è£¡æ˜¯å¦æœ‰é€™å€‹ Block
            const hit = data.find(d => Number(d.Block) === item.block);   // JSON æ¬„ä½ "Block" åƒè€ƒ&#8203;:contentReference[oaicite:0]{index=0}&#8203;:contentReference[oaicite:1]{index=1}
            if (hit) {
            makeTopLabel(font, hit.lon, hit.lat, item.text, item.height);
            } else {
            console.warn('æ‰¾ä¸åˆ° Block =', item.block);
            }
        });
        }



        function createText(font, origin, text, type) {
            var radius = 3.6;
            var height = 4;
            var textGeometry = new THREE.TextGeometry(text.toString(), {
                font: font,
                size: 1.5, // æ–‡å­—å¤§å°
                height: 0.2, // æ–‡å­—åšåº¦
            });

            var textMaterial = new THREE.MeshBasicMaterial({ color: '#fff' });
            var textMesh = new THREE.Mesh(textGeometry, textMaterial);

            var edgesGeometry = new THREE.EdgesGeometry(textGeometry);
            var edgesMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
            var edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);

            var cube = new THREE.Group();
            cube.add(textMesh);
            cube.add(edges);

            var mesh3D = tb.Object3D({ obj: cube, units: 'meters' });
            mesh3D.rotateX(Math.PI / 2);
            mesh3D.rotateY(Math.PI);
            
            rx = mesh3D.bottomRight.x;
            lx = mesh3D.bottomLeft.x;
            w = (lx - rx) / 2;

            var newCoord = calculateNewCoordinates(origin[1], origin[0], w, 90)
            var newCoord2 = calculateNewCoordinates(newCoord.lat, newCoord.lon, 2.5, 180)
            height = 7;
            if(type == 2) {
                height = 3;
            }
            mesh3D.setCoords([newCoord2.lon, newCoord2.lat, height]);
            

            return mesh3D;
        }

        function createBackText(font, origin, text, type) {
            var radius = 3.6;
            var height = 4;
            
            var textGeometry = new THREE.TextGeometry(text.toString(), {
                font: font,
                size: 1.6, // æ–‡å­—å¤§å°
                height: 0.2, // æ–‡å­—åšåº¦
            });

            var textMaterial = new THREE.MeshBasicMaterial({ color: '#fff' });
            var textMesh = new THREE.Mesh(textGeometry, textMaterial);

            var edgesGeometry = new THREE.EdgesGeometry(textGeometry);
            var edgesMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
            var edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);

            var cube = new THREE.Group();
            cube.add(textMesh);
            cube.add(edges);

            var mesh3D = tb.Object3D({ obj: cube, units: 'meters' });
            mesh3D.rotateX(Math.PI / 2);
            // mesh3D.rotateY(Math.PI);
            
            rx = mesh3D.bottomRight.x;
            lx = mesh3D.bottomLeft.x;
            w = (lx - rx) / 2;

            var newCoord = calculateNewCoordinates(origin[1], origin[0], w, -90)
            var newCoord2 = calculateNewCoordinates(newCoord.lat, newCoord.lon, -2.5, 180)
            height = 7;
            if(type == 2) {
                height = 3;
            }
            mesh3D.setCoords([newCoord2.lon, newCoord2.lat, height]);

            return mesh3D;
        }

        




        function createSegmentCapsule(origin, pmv, sTemp, integration) {

            let radius = 2.5;
            let widthSegments = 32;

            // æœ‰é›™é‚Šç¢¼ / æœ‰é›™è®Š 
            // let topCylinderHeight = radius * (1 + ((pmv + 3)/6)*4);       // æ˜ å°„ pmv (-3 ~ 3) -> (1 ~ 2)
            // let bottomCylinderHeight = radius * (1 + ((sTemp + 3)/6)*4);  // æ˜ å°„ sTemp (-3 ~ 3) -> (1 ~ 2)
            // let CylinderWitdth=integration*radius

            // æœ‰é›™ç·¨ç¢¼ / ç„¡é›™è®Š 
            // let topCylinderHeight = radius * (1 + ((pmv + 3)/6)*4);       // æ˜ å°„ pmv (-3 ~ 3) -> (1 ~ 2)
            // let bottomCylinderHeight = radius * (1 + ((sTemp + 3)/6)*4);  // æ˜ å°„ sTemp (-3 ~ 3) -> (1 ~ 2)
            // let CylinderWitdth=radius

            
            // ç„¡é›™ç·¨ç¢¼ / ç„¡é›™è®Š  
            // let topCylinderHeight = radius*3 ;      
            // let bottomCylinderHeight = radius*3 ;  
            // let CylinderWitdth=radius

            // ç„¡é›™ç·¨ç¢¼ / æœ‰é›™è®Š  
            let topCylinderHeight = radius*3 ;      
            let bottomCylinderHeight = radius*3 ;  
            let CylinderWitdth=integration*radius

            var materialTop = new THREE.MeshBasicMaterial({ color: getPMVColor(pmv) ,transparent: false ,fog:false});
            var materialBottom = new THREE.MeshBasicMaterial({ color: getSubjectTempColor(sTemp),transparent: false,fog: false});

            var upperGeometry = new THREE.SphereGeometry(CylinderWitdth, widthSegments, widthSegments / 2, 0, Math.PI); //radius : Float, widthSegments : Integer, heightSegments 
            var lowerGeometry = new THREE.SphereGeometry(CylinderWitdth, widthSegments, widthSegments / 2, Math.PI, Math.PI);

            var upperMesh = new THREE.Mesh(upperGeometry, materialTop);
            var lowerMesh = new THREE.Mesh(lowerGeometry, materialBottom);
            upperMesh.position.z = topCylinderHeight/2;
            lowerMesh.position.z = -(bottomCylinderHeight+topCylinderHeight/2);

            var cylinderGeometry1 = new THREE.CylinderGeometry(CylinderWitdth, CylinderWitdth,topCylinderHeight, widthSegments); // åƒæ•¸åˆ†åˆ¥ç‚ºé ‚éƒ¨åŠå¾‘ã€åº•éƒ¨åŠå¾‘ã€é«˜åº¦å’Œåœ“æŸ±é«”åˆ†æ®µæ•¸
            var cylinder1 = new THREE.Mesh(cylinderGeometry1, materialTop);
            cylinder1.rotateX(Math.PI / 2);
            // cylinder1.position.z = -(topCylinderHeight / 2);

            var cylinderGeometry2 = new THREE.CylinderGeometry(CylinderWitdth, CylinderWitdth, bottomCylinderHeight, widthSegments); // åƒæ•¸åˆ†åˆ¥ç‚ºé ‚éƒ¨åŠå¾‘ã€åº•éƒ¨åŠå¾‘ã€é«˜åº¦å’Œåœ“æŸ±é«”åˆ†æ®µæ•¸
            var cylinder2 = new THREE.Mesh(cylinderGeometry2, materialBottom);
            cylinder2.rotateX(Math.PI / 2);
            cylinder2.position.z = -(bottomCylinderHeight/2+topCylinderHeight/2);

            var cylinderGeometry3 = new THREE.CylinderGeometry(CylinderWitdth*1.05, CylinderWitdth*1.05, 1, widthSegments); // åƒæ•¸åˆ†åˆ¥ç‚ºé ‚éƒ¨åŠå¾‘ã€åº•éƒ¨åŠå¾‘ã€é«˜åº¦å’Œåœ“æŸ±é«”åˆ†æ®µæ•¸
            var material3 = new THREE.MeshBasicMaterial({ 
                color: "#FFFFFF", // ç™½è‰²
                transparent: true, // å•Ÿç”¨é€æ˜æ•ˆæœ
                opacity: 0.9 // è¨­å®šé€æ˜åº¦ç‚º 50%
            });
            var cylinder3 = new THREE.Mesh(cylinderGeometry3, material3);
            cylinder3.rotateX(Math.PI / 2);
            cylinder3.position.z = -(topCylinderHeight/2);

            var capsule = new THREE.Group();
            // capsule.add(upperMesh);
            capsule.add(cylinder1);
            capsule.add(cylinder2);
            capsule.add(cylinder3);
            // capsule.add(lowerMesh);

            // var totalHeight = topCylinderHeight;
            // var centerOffsetZ =topCylinderHeight/2;
            capsule.position.z =bottomCylinderHeight+radius;

            var newCoord = calculateNewCoordinates(origin[1], origin[0], CylinderWitdth, -90)
            var newCoord2 = calculateNewCoordinates(newCoord.lat, newCoord.lon, CylinderWitdth , 180)

            var capsule3D = tb.Object3D({ obj: capsule, units: 'meters' });
            capsule3D.setCoords([newCoord2.lon, newCoord2.lat, capsuleHeight]);

            return capsule3D;
        }



        function createLine(origin) {
            //ç•«ç·š
            var startPoint = origin.concat(1);
            var endPoint = origin.concat(capsuleHeight);
            var lineOptions = {
                geometry: [startPoint, endPoint],
                color: "white",
                width: 1
            }
            let lineMesh = tb.line(lineOptions);
            return lineMesh;
        }

        function createGroundSquare(origin, pmv, sTemp) {
            var radius = 3.6;
            var height = 4;
            // å‰µå»ºç´…è‰²ä¸‰è§’éŒ
            var redGeometry = new THREE.CylinderGeometry(0, radius, height, 4, 1)
            var redMaterial = new THREE.MeshBasicMaterial({ color: getPMVColor(pmv) });
            var redCone = new THREE.Mesh(redGeometry, redMaterial);
            redCone.rotateX(Math.PI / 2);

            // å‰µå»ºé»ƒè‰²ä¸‰è§’éŒ
            var yellowGeometry = new THREE.CylinderGeometry(0, radius, height, 4, 1)
            var yellowMaterial = new THREE.MeshBasicMaterial({ color: getSubjectTempColor(sTemp) });
            var yellowCone = new THREE.Mesh(yellowGeometry, yellowMaterial);
            yellowCone.position.set(0, 0, -(height)); // å°‡ä¸‰è§’éŒç§»è‡³ x è»¸ä¸Š
            yellowCone.rotateX(-(Math.PI / 2));

            var cube = new THREE.Group();
            cube.add(redCone);
            // cube.add(redEdges);
            cube.add(yellowCone);
            // cube.add(yellowEdges);

            var mesh3D = tb.Object3D({ obj: cube, units: 'meters' });
            var newCoord = calculateNewCoordinates(origin[1], origin[0], radius, -90)
            var newCoord2 = calculateNewCoordinates(newCoord.lat, newCoord.lon, radius / 2 * 2, 180)
            mesh3D.setCoords([newCoord2.lon, newCoord2.lat, 0]);

            return mesh3D;
        }

        function calculateNewCoordinates(lat1, lon1, distance, angle) {
            var R = 6371000; // åœ°çƒåŠå¾‘ï¼Œå–®ä½å…¬å°º
            var d = distance / R; // angular distance in radians
            var bearing = angle * (Math.PI / 180); //å°‡è§’åº¦è½‰ç‚ºå¼§åº¦

            var lat1Rad = lat1 * (Math.PI / 180);
            var lon1Rad = lon1 * (Math.PI / 180);

            var lat2Rad = Math.asin(Math.sin(lat1Rad) * Math.cos(d) + Math.cos(lat1Rad) * Math.sin(d) * Math.cos(bearing));
            var lon2Rad = lon1Rad + Math.atan2(Math.sin(bearing) * Math.sin(d) * Math.cos(lat1Rad), Math.cos(d) - Math.sin(lat1Rad) * Math.sin(lat2Rad));

            var lat2 = lat2Rad * (180 / Math.PI);
            var lon2 = lon2Rad * (180 / Math.PI);

            return { lat: lat2, lon: lon2 };
        }

        function createACapsule(font, origin, pmv, sTemp,integration) {
            var sphere = tb.sphere({ color: 'red', material: 'MeshToonMaterial' })
                .setCoords(origin);
            tb.add(createLine(origin));
            tb.add(createSegmentCapsule(origin, pmv, sTemp,integration));
            tb.add(createGroundSquare(origin, pmv, sTemp));
            tb.add(createText(font, origin, pmv, 1));
            tb.add(createText(font, origin, sTemp, 2));
            tb.add(createBackText(font, origin, pmv, 1));
            tb.add(createBackText(font, origin, sTemp, 2));
        }

        map.on('load', function () {
            var loader = new THREE.FontLoader();
            loader.load('https://cdn.rawgit.com/mrdoob/three.js/master/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                map.addLayer({
                    id: 'custom_layer',
                    type: 'custom',
                    renderingMode: '3d',
                    onAdd: function (map, mbxContext) {
                        $.getJSON("./data/0910M_P3.json", function (data) {
                            window.tb = new Threebox(
                                map,
                                mbxContext,
                                {
                                    
                                    defaultLights: false, // ç¦ç”¨å…‰æº
                                    enableSelectingObjects: true,
                                    realSunlight: false, // ç¦ç”¨çœŸå¯¦é™½å…‰æ•ˆæœ
                                    gltfLoader: false // ç¦ç”¨ä¸å¿…è¦çš„è¼‰å…¥å™¨
                                    
                                    
                                }
                            );

                            var ambientLight = new THREE.AmbientLight(0xffffff, 2);
                            tb.add(ambientLight);


                            for (var i = 0; i < data.length; i++) {
                                
                                    createACapsule(font, [data[i]['lon'], data[i]['lat']], parseFloat(data[i]['heat_7-value'].toFixed(1)), parseFloat(data[i]['pmv'].toFixed(1)), parseFloat(data[i]['Integration (HH) R3'].toFixed(1)));
                                
                            }
                            addAllLabels(font, data);

                        });
                    },
                    render: function (gl, matrix) {
                        if (typeof tb !== 'undefined') {
                            tb.update();
                        }
                    }
                });
            });
        });
        
    
    </script>

</body>

</html>